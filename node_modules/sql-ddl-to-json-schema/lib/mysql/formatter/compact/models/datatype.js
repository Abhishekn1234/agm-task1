"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Datatype = void 0;
const utils_1 = require("../../../../shared/utils");
/**
 * Data type.
 */
class Datatype {
    datatype;
    displayWidth;
    digits;
    decimals;
    length;
    fractional;
    values;
    binaryCollation;
    /**
     * Creates a datatype from a JSON def.
     *
     * @param json JSON format parsed from SQL.
     */
    static fromDef(json) {
        if (json.id === 'O_DATATYPE') {
            const datatype = new Datatype();
            Object.assign(datatype, json.def.def);
            datatype.datatype = Datatype.filterDatatype(datatype.datatype);
            return datatype;
        }
        throw new TypeError(`Unknown json id to build datatype from: ${json.id}`);
    }
    /**
     * Get standardized name for datatype, according to parsed JSON term.
     *
     * @param term Datatype term parsed JSON format.
     */
    static filterDatatype(term) {
        const lowerTerm = term.toLowerCase();
        if (lowerTerm === 'integer') {
            return 'int';
        }
        if (lowerTerm === 'numeric') {
            return 'decimal';
        }
        if (lowerTerm === 'bool') {
            return 'boolean';
        }
        if (lowerTerm === 'tinyblob') {
            return 'blob';
        }
        if (lowerTerm === 'mediumblob') {
            return 'blob';
        }
        if (lowerTerm === 'longblob') {
            return 'blob';
        }
        if (lowerTerm === 'tinytext') {
            return 'text';
        }
        if (lowerTerm === 'mediumtext') {
            return 'text';
        }
        if (lowerTerm === 'longtext') {
            return 'text';
        }
        if (lowerTerm === 'national char') {
            return 'char';
        }
        if (lowerTerm === 'nvarchar') {
            return 'varchar';
        }
        if (lowerTerm === 'character') {
            return 'char';
        }
        if (lowerTerm === 'nchar') {
            return 'char';
        }
        if (lowerTerm === 'uniqueidentifier') {
            return 'uuid';
        }
        return lowerTerm;
    }
    /**
     * Get length that is indexable by this datatype.
     */
    getMaxIndexableSize() {
        /**
         * Non-indexable datatypes.
         */
        if ([
            'tinyint',
            'smallint',
            'mediumint',
            'int',
            'bigint',
            'decimal',
            'float',
            'double',
            'bit',
            'boolean',
            'date',
            'time',
            'datetime',
            'timestamp',
            'year',
            'json',
            'uuid',
        ].includes(this.datatype)) {
            return 0;
        }
        /**
         * Indexable, but dynamic length, user-defined only.
         */
        if ([
            'geometry',
            'point',
            'linestring',
            'polygon',
            'multipoint',
            'multilinestring',
            'multipolygon',
            'geometrycollection',
        ].includes(this.datatype)) {
            return 0;
        }
        /**
         * Indexable datatypes.
         */
        if (['blob', 'text', 'char', 'binary', 'varchar', 'nvarchar', 'varbinary'].includes(this.datatype)) {
            return this.length;
        }
        return 0;
    }
    /**
     * JSON casting of this object calls this method.
     */
    toJSON() {
        const json = {
            datatype: this.datatype,
        };
        if ((0, utils_1.isDefined)(this.displayWidth)) {
            json.displayWidth = this.displayWidth;
        }
        if ((0, utils_1.isDefined)(this.digits)) {
            json.digits = this.digits;
        }
        if ((0, utils_1.isDefined)(this.decimals)) {
            json.decimals = this.decimals;
        }
        if ((0, utils_1.isDefined)(this.length)) {
            json.length = this.length;
        }
        if ((0, utils_1.isDefined)(this.fractional)) {
            json.fractional = this.fractional;
        }
        if ((0, utils_1.isDefined)(this.values)) {
            json.values = this.values;
        }
        if ((0, utils_1.isDefined)(this.binaryCollation)) {
            json.binaryCollation = this.binaryCollation;
        }
        return json;
    }
    /**
     * Create a deep clone of this model.
     */
    clone() {
        const datatype = new Datatype();
        datatype.datatype = this.datatype;
        if ((0, utils_1.isDefined)(this.displayWidth)) {
            datatype.displayWidth = this.displayWidth;
        }
        if ((0, utils_1.isDefined)(this.digits)) {
            datatype.digits = this.digits;
        }
        if ((0, utils_1.isDefined)(this.decimals)) {
            datatype.decimals = this.decimals;
        }
        if ((0, utils_1.isDefined)(this.length)) {
            datatype.length = this.length;
        }
        if ((0, utils_1.isDefined)(this.fractional)) {
            datatype.fractional = this.fractional;
        }
        if ((0, utils_1.isDefined)(this.values)) {
            datatype.values = this.values.slice();
        }
        return datatype;
    }
}
exports.Datatype = Datatype;
